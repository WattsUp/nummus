# Initially generated by Pyright

from collections.abc import Callable
from typing import Literal, Self

import flask
import prometheus_client
from flask.typing import ResponseReturnValue
from prometheus_client import Gauge
from werkzeug.exceptions import HTTPException

GroupBy = Literal["path", "endpoint", "url_rule"]

Responder = Callable[..., ResponseReturnValue | object | HTTPException | flask.Response]

class PrometheusMetrics:
    def __init__[T: Callable[..., object]](
        self,
        app: flask.Flask,
        path: str = ...,
        export_defaults: bool = ...,
        defaults_prefix: str = ...,
        group_by: GroupBy = ...,
        buckets: tuple[float, ...] | None = ...,
        default_latency_as_histogram: bool = ...,
        default_labels: dict[str, object] | None = ...,
        response_converter: Responder = ...,
        excluded_paths: list[str] | str | None = ...,
        exclude_user_defaults: bool = ...,
        metrics_decorator: Callable[[T], T] = ...,
        registry: prometheus_client.CollectorRegistry | None = ...,
        **kwargs: object,
    ) -> None: ...
    @classmethod
    def for_app_factory(cls, **kwargs: object) -> Self: ...
    def init_app(self, app: flask.Flask) -> None: ...
    def register_endpoint(self, path: str, app: flask.Flask = ...) -> None: ...
    def generate_metrics(
        self,
        accept_header: str | None = ...,
        names: list[str] | None = ...,
    ) -> tuple[str, str]: ...
    def start_http_server(
        self,
        port: int,
        host: str = ...,
        endpoint: str = ...,
        ssl: dict[str, str] | None = ...,
    ) -> None: ...
    def export_defaults(
        self,
        buckets: tuple[float, ...] | None = ...,
        group_by: GroupBy = ...,
        latency_as_histogram: bool = ...,
        prefix: str = ...,
        app: flask.Flask = ...,
        **kwargs: object,
    ) -> None: ...
    def register_default[T: Callable[..., object]](
        self,
        *metric_wrappers: Callable[[T], T],
        **kwargs: object,
    ) -> None: ...
    def histogram(
        self,
        name: str,
        description: str,
        labels: dict[str, object] | None = ...,
        initial_value_when_only_static_labels: bool = ...,
        **kwargs: str,
    ) -> Callable[..., Responder]: ...
    def summary(
        self,
        name: str,
        description: str,
        labels: dict[str, object] | None = ...,
        initial_value_when_only_static_labels: bool = ...,
        **kwargs: str,
    ) -> Callable[..., Responder]: ...
    def gauge(
        self,
        name: str,
        description: str,
        labels: dict[str, object] | None = ...,
        initial_value_when_only_static_labels: bool = ...,
        **kwargs: str,
    ) -> Callable[..., Responder]: ...
    def counter(
        self,
        name: str,
        description: str,
        labels: dict[str, object] | None = ...,
        initial_value_when_only_static_labels: bool = ...,
        **kwargs: str,
    ) -> Callable[..., Responder]: ...
    @staticmethod
    def do_not_track[T: Callable[..., object]]() -> Callable[[T], T]: ...
    @staticmethod
    def exclude_all_metrics[T: Callable[..., object]]() -> Callable[[T], T]: ...
    def info(
        self,
        name: str,
        description: str,
        labelnames: tuple[str, ...] | None = ...,
        labelvalues: tuple[object, ...] | None = ...,
        **labels: object,
    ) -> Gauge: ...
